<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<head>
  <title>up (UpdateAcceptDatacolumnValues)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre><span class="ruby-comment cmt"># File db/migrate/20110816084514_update_accept_datacolumn_values.rb, line 2</span>
  <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">up</span>
    <span class="ruby-identifier">execute</span> <span class="ruby-value str">&quot;\n--\n-- Name: insert_sheet_category(integer, integer, integer, text); Type: FUNCTION; Schema: public; Owner: -\n--\n\nCREATE OR REPLACE FUNCTION insert_sheet_category(sheetcategory_id integer, datagroup_id integer, status_id integer, import_value text) RETURNS integer\nLANGUAGE sql\nAS $_$\ninsert into categories (short, long, description, comment, created_at, updated_at, datagroup_id, user_id, status_id)\n(select short, long, description, comment, now() as created_at, now() as updated_at, $2 as datagroup_id, user_id, $3 as status_id\nfrom categories where id = $1);\n\nselect id from categories where (short=$4 or long=$4) and datagroup_id = $2;$_$;\n\n\n\n--\n-- Name: accept_datacolumn_values(integer, integer, integer, integer, integer, text); Type: FUNCTION; Schema: public; Owner: -\n--\n\nCREATE OR REPLACE FUNCTION accept_datacolumn_values(datatype_id integer, datacolumn_id integer, datagroup_id integer, system_datagroup_id integer, user_id integer, \&quot;comment\&quot; text) RETURNS boolean\nLANGUAGE sql\nAS $_$-- regardless of the data type we search for portal matches first\nupdate sheetcells\nset category_id= c.id,\nupdated_at = now(),\ndatatype_id = 5, -- whatever the original data type this is now a category data type\naccepted_value = null,\nstatus_id = 3\nfrom categories c\nwhere (sheetcells.import_value=c.short or sheetcells.import_value=c.long)\nand sheetcells.datacolumn_id=$2 and c.datagroup_id = $3;\n\n-- regardless of the data type we search for sheet matches next\nupdate sheetcells\nset category_id = insert_sheet_category(c.id, $3, 1, sheetcells.import_value),\nupdated_at = now(),\ndatatype_id = 5, -- whatever the original data type this is now a category data type\naccepted_value=null,\nstatus_id = 2\nfrom categories c inner join import_categories cv on c.id = cv.category_id\nwhere (sheetcells.import_value=c.short or sheetcells.import_value=c.long)\nand sheetcells.datacolumn_id=$2 and cv.datacolumn_id=$2\nand sheetcells.category_id is null and c.datagroup_id=$4;\n\n-- valid number, date &amp; year\nupdate sheetcells\nset category_id = null,\naccepted_value = sheetcells.import_value,\nupdated_at = now(),\ndatatype_id = $1,\nstatus_id = 4\nwhere sheetcells.datacolumn_id=$2\nand (($1 = 7 and isnumeric(sheetcells.import_value) = true)\nor ($1 = 2 and isinteger(sheetcells.import_value) = true)\nor (($1 = 3 or $1 = 4) and isdate(sheetcells.import_value) = true)\n)\nand sheetcells.category_id is null;\n\n-- regardless of the data type any sheetcells left over are invalid and categories created for them\n-- this is a two step process to avoid duplicate categories being created\n\n-- 1. add a category for each unique invalid value, as long as one doesn't already exist in the data group\ninsert into categories (short, long, description, datagroup_id, status_id, created_at, updated_at, user_id, comment)\n(select distinct sheetcells.import_value, sheetcells.import_value, sheetcells.import_value, $3 as datagroup_id, 3 as status_id, now() as created_at, now() as updated_at,\n1 as user_id, $6 as comment\nfrom sheetcells\nwhere sheetcells.datacolumn_id=$2 and sheetcells.category_id is null\nand sheetcells.accepted_value is null and sheetcells.status_id = 1\nand not exists (select 1 from categories where (short = sheetcells.import_value or long = sheetcells.import_value) and datagroup_id = $3));\n\n\n-- 2. update the sheet cells with the correct category\nupdate sheetcells\nset category_id= c.id,\nupdated_at = now(),\ndatatype_id = 5, -- whatever the original data type this is now a category data type\naccepted_value = null,\nstatus_id = 5 -- it is an invalid category\nfrom categories c\nwhere (sheetcells.import_value=c.short or sheetcells.import_value=c.long)\nand sheetcells.datacolumn_id=$2 and c.datagroup_id = $3 and sheetcells.category_id is null and sheetcells.accepted_value is null\n\nreturning true$_$;\n\n&quot;</span>
  <span class="ruby-keyword kw">end</span></pre>
</body>
</html>