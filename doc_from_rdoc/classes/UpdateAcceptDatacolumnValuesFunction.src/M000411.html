<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<head>
  <title>up (UpdateAcceptDatacolumnValuesFunction)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre><span class="ruby-comment cmt"># File db/migrate/20110824120309_update_accept_datacolumn_values_function.rb, line 2</span>
  <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">up</span>
    <span class="ruby-identifier">execute</span> <span class="ruby-value str">&quot;\nCREATE OR REPLACE FUNCTION accept_datacolumn_values(datatype_id integer, datacolumn_id integer, datagroup_id integer, user_id integer, \&quot;comment\&quot; text) RETURNS boolean\nLANGUAGE sql\nAS $_$          -- regardless of the data type we search for portal matches first\nupdate sheetcells\nset category_id= c.id,\nupdated_at = now(),\ndatatype_id = 5, -- whatever the original data type this is now a category data type\naccepted_value = null,\nstatus_id = 3\nfrom categories c\nwhere (sheetcells.import_value=c.short or sheetcells.import_value=c.long)\nand sheetcells.datacolumn_id=$2 and c.datagroup_id = $3;\n\n-- regardless of the data type we search for sheet matches next\n-- this is a two step process to avoid duplicate categories being created\n-- 1. add a category for each unique sheet category match, as long as one doesn't already exist in the data group\ninsert into categories (short, long, description, datagroup_id, status_id, created_at, updated_at, user_id, comment)\n(select distinct ic.short, ic.long, ic.description, $3 as datagroup_id, 1 as status_id, now() as created_at, now() as updated_at,\n$4 as user_id, $5 as comment\nfrom import_categories ic inner join sheetcells s on (s.import_value=ic.short or s.import_value=ic.long)\nand s.datacolumn_id=$2 and ic.datacolumn_id=$2\nand s.category_id is null and s.status_id = 1\nand not exists (select 1 from categories where (short = s.import_value or long = s.import_value) and datagroup_id = $3));\n\n-- 2. update the sheet cells with the correct category\nupdate sheetcells\nset category_id= c.id,\nupdated_at = now(),\ndatatype_id = 5, -- whatever the original data type this is now a category data type\naccepted_value = null,\nstatus_id = 2 -- it is an sheet match category\nfrom categories c\nwhere (sheetcells.import_value=c.short or sheetcells.import_value=c.long)\nand sheetcells.datacolumn_id=$2 and c.datagroup_id = $3 and sheetcells.category_id is null and sheetcells.accepted_value is null;\n\n-- valid number, date &amp; year\nupdate sheetcells\nset category_id = null,\naccepted_value = sheetcells.import_value,\nupdated_at = now(),\ndatatype_id = $1,\nstatus_id = 4\nwhere sheetcells.datacolumn_id=$2\nand (($1 = 7 and isnumeric(sheetcells.import_value) = true)\nor ($1 = 2 and isinteger(sheetcells.import_value) = true)\nor (($1 = 3 or $1 = 4) and isdate(sheetcells.import_value) = true)\n)\nand sheetcells.category_id is null;\n\n-- regardless of the data type any sheetcells left over are flagged as invalid\nupdate sheetcells\nset updated_at = now(),\ndatatype_id = $1,\nstatus_id = 5 -- invalid\nwhere sheetcells.datacolumn_id=$2 and sheetcells.category_id is null and sheetcells.accepted_value is null\nreturning true$_$;\n\n\n&quot;</span>
  <span class="ruby-keyword kw">end</span></pre>
</body>
</html>