<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<head>
  <title>up (AddFunctionForAddingDataValues)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre><span class="ruby-comment cmt"># File db/migrate/20110701123950_add_function_for_adding_data_values.rb, line 2</span>
  <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">up</span>
    <span class="ruby-identifier">execute</span> <span class="ruby-value str">&quot;\n--\n-- Name: accept_text_datacolumn_values(integer); Type: FUNCTION; Schema: public; Owner: -\n--\n\nCREATE OR REPLACE FUNCTION accept_text_datacolumn_values(datacolumn_id integer) RETURNS boolean\nLANGUAGE sql\nAS $_$-- text data types are not linked to categories so we can just update the accepted value\nupdate sheetcells\nset category_id = null,\naccepted_value=sheetcells.import_value,\nupdated_at = now(),\ndatatype_id = 1,\nstatus_id = 4\nwhere sheetcells.datacolumn_id=$1\nreturning true;$_$;\n\n\n--\n-- Name: clear_datacolumn_accepted_values(integer); Type: FUNCTION; Schema: public; Owner: -\n--\n\nCREATE OR REPLACE FUNCTION clear_datacolumn_accepted_values(datacolumn_id integer) RETURNS boolean\nLANGUAGE sql\nAS $_$update sheetcells\nset accepted_value=null,\ncategory_id=null,\nstatus_id=1\nwhere datacolumn_id=$1\n\nreturning true$_$;\n\n\n--\n-- Name: insert_category(text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -\n--\n\nCREATE OR REPLACE FUNCTION insert_category(short text, long text, datagroup_id integer, status_id integer) RETURNS integer\nLANGUAGE sql\nAS $_$insert into categories (short, long, datagroup_id, status_id, created_at, updated_at)\n(select $1 as short, $2 as long, $3 as datagroup_id, $4 as status_id, now() as created_at, now() as updated_at where\nnot exists (select 1 from categories where (short=$1 or long=$2) and datagroup_id = $3));\n\nselect id from categories where (short=$1 or long=$2) and datagroup_id = $3;$_$;\n\n\n--\n-- Name: isdate(text); Type: FUNCTION; Schema: public; Owner: -\n--\n\nCREATE OR REPLACE FUNCTION isdate(text text) RETURNS boolean\nLANGUAGE plpgsql\nAS $_$begin\nif $1 is null then\nreturn 0;\nelse\nperform $1::date;\nreturn 1;\nend if;\nexception when others then\nreturn 0;\nend$_$;\n\n\n--\n-- Name: isinteger(text); Type: FUNCTION; Schema: public; Owner: -\n--\n\nCREATE OR REPLACE FUNCTION isinteger(year text) RETURNS boolean\nLANGUAGE sql\nAS $_$select $1 ~ '^[0-9]+$'$_$;\n\n\n--\n-- Name: isnumeric(text); Type: FUNCTION; Schema: public; Owner: -\n--\n\nCREATE OR REPLACE FUNCTION isnumeric(text text) RETURNS boolean\nLANGUAGE sql\nAS $_$select $1 ~\n'^[0-9]+.?[0-9]*$'$_$;\n\n\n--\n-- Name: isyear(text); Type: FUNCTION; Schema: public; Owner: -\n--\n\nCREATE OR REPLACE FUNCTION isyear(year text) RETURNS boolean\nLANGUAGE sql\nAS $$select 1=1$$;\n\n\n--\n-- Name: accept_datacolumn_values(integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -\n--\n\nCREATE OR REPLACE FUNCTION accept_datacolumn_values(datatype_id integer, datacolumn_id integer, datagroup_id integer, system_datagroup_id integer) RETURNS boolean\nLANGUAGE sql\nAS $_$          -- regardless of the data type we search for portal matches first\nupdate sheetcells\nset category_id= c.id,\nupdated_at = now(),\ndatatype_id = 5, -- whatever the original data type this is now a category data type\naccepted_value = null,\nstatus_id = 3\nfrom categories c\nwhere (sheetcells.import_value=c.short or sheetcells.import_value=c.long)\nand sheetcells.datacolumn_id=$2 and c.datagroup_id = $3;\n\n-- regardless of the data type we search for sheet matches next\nupdate sheetcells\nset category_id = insert_category(sheetcells.import_value, sheetcells.import_value, $3, 1),\nupdated_at = now(),\ndatatype_id = 5, -- whatever the original data type this is now a category data type\naccepted_value=null,\nstatus_id = 2\nfrom categories c inner join import_categories cv on c.id = cv.category_id\nwhere (sheetcells.import_value=c.short or sheetcells.import_value=c.long)\nand sheetcells.datacolumn_id=$2 and cv.datacolumn_id=$2\nand sheetcells.category_id is null and c.datagroup_id=$4;\n\n-- valid number, date &amp; year\nupdate sheetcells\nset category_id = null,\naccepted_value = sheetcells.import_value,\nupdated_at = now(),\ndatatype_id = $1,\nstatus_id = 4\nwhere sheetcells.datacolumn_id=$2\nand ((datatype_id = 7 and isnumeric(sheetcells.import_value) = true)\nor (datatype_id = 2 and isinteger(sheetcells.import_value) = true)\nor ((datatype_id = 3 or datatype_id = 4) and isdate(sheetcells.import_value) = true)\n)\nand sheetcells.category_id is null;\n\n-- regardless of the data type any sheetcells left over are invalid and categories created for them\nupdate sheetcells\nset category_id = insert_category(sheetcells.import_value, sheetcells.import_value, $3, 3),\naccepted_value = null,\nupdated_at = now(),\ndatatype_id = 5, -- whatever the original data type this is now a category data type\nstatus_id = 5\nwhere sheetcells.datacolumn_id=$2 and sheetcells.category_id is null and sheetcells.accepted_value is null\nreturning true$_$;\n\n&quot;</span>
  <span class="ruby-keyword kw">end</span></pre>
</body>
</html>